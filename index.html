<html>
  <head>
    <link rel="stylesheet" href="index.css">
  </head>
  <body>
    <div id="brot-container">
      <div id="ui">
        <div>
          <div>
          <span>zoom amount: <span id="scale-value"></span></span>
          <span>,&nbsp;</span>
          <span>centered at: <span id="centered-value"></span></span>
          </div>
          <div id="hovered-value"></div>
        </div>
        <div>
          <button id="reset-button">reset</button>
        </div>
      </div>
      <canvas id="brot" width="1000" height="1000"></canvas>
      <div id="helper">click wherever you want to zoom</div>
    </div>
    <script>
      const canvas = document.getElementById("brot");

      const RESOLUTION = canvas.clientWidth;

      // number of iterations we stop at to define a pixel as in the mandelbrot set (black)
      // lower is faster but will give you a less defined final image
      const MAX_ITER = 0xfe;

      class Complex {
        constructor(r, i) {
          this.r = r;
          this.i = i;
        }

        toString() {
          return `${this.r} ${this.i < 0 ? "-" : "+"} ${Math.abs(this.i)}i`;
        }

        add(x) {
          let r, i;
          if (x instanceof Complex) {
            r = this.r + x.r;
            i = this.i + x.i;
          } else if (typeof x === "number") {
            r = this.r + x;
            i = this.i;
          }
          return new Complex(r, i);
        }

        sub(x) {
          let r, i;
          if (x instanceof Complex) {
            r = this.r - x.r;
            i = this.i - x.i;
          } else if (typeof x === "number") {
            r = this.r - x;
            i = this.i;
          }
          return new Complex(r, i);
        }

        mul(x) {
          let r, i;
          if (x instanceof Complex) {
            r = (this.r * x.r) - (this.i * x.i);
            i = (this.r * this.i) + (x.r * x.i);
          } else if (typeof x === "number") {
            r = this.r * x;
            i = this.i * x;
          }
          return new Complex(r, i);
        }

        square() {
          return this.mul(this);
        }

        // distance from point to (0, 0)
        abs() {
          return Math.sqrt((this.r ** 2) + (this.i ** 2))
        }

        // sets `Z(0)` of the julia function
        juliaInit() {
          return new Complex(0, 0);
        }

        // next.square().add(this) is the equivalent to `Z(n) = Z(n-1)^2 + c`
        juliaFunction(next) {
          return next.square().add(this);
        }


        stepsToInfinity() {
          let iterations = 0;
          let next = this.juliaInit();
          while (iterations < MAX_ITER && next.abs() < 2) {
            ++iterations;
            next = this.juliaFunction(next);
          }
          return iterations
        }
      }

      const invertSteps = (n) => {
        return (n * -1) + MAX_ITER;
      }

      const getColor = (n) => {
        const _n = invertSteps(n);
        const hex = Math.floor((_n * 0xfff) / MAX_ITER).toString(16).padStart(3, "0");
        return [...hex].map(x => parseInt(x, 16) * 17);
      }

      const getGreyscale = (n) => {
        return (invertSteps(n) / MAX_ITER) * 0xff
      }


      const scale = (value, outMin, outMax) => {
        return (value) * (outMax - outMin) / RESOLUTION + outMin;
      }

      let CENTER, SCALE, MAX_X, MAX_Y, MIN_X, MIN_Y;

      const initValues = () => {
        CENTER = new Complex(0, 0);
        SCALE = 1;
        MAX_X = SCALE * (2 + CENTER.r);
        MIN_X = SCALE * (-2 + CENTER.r);
        MAX_Y = SCALE * (-2 + CENTER.i);
        MIN_Y = SCALE * (2 + CENTER.i);

        document.getElementById("centered-value").textContent = CENTER.toString();
        document.getElementById("scale-value").textContent = `2^${Math.log2(1/SCALE)}`;
      }

      initValues();

      const recenterAndZoom = (newCenter) => {
        CENTER = newCenter;
        SCALE *= 0.5;
        MAX_X = (SCALE * 2) + CENTER.r;
        MIN_X = (SCALE * -2) + CENTER.r;
        MAX_Y = (SCALE * -2) + CENTER.i;
        MIN_Y = (SCALE * 2) + CENTER.i;
      }

      const ctx = canvas.getContext("2d", { alpha: false, willReadFrequently: true })

      const doWork = () => {
        const imageData = ctx.getImageData(0, 0, RESOLUTION, RESOLUTION);
        const pixels = imageData.data;

        for (let y = 0; y <= RESOLUTION; ++y) {
          for (let x = 0; x <= RESOLUTION; ++x) {
            const normX = scale(x, MIN_X, MAX_X);
            const normY = scale(y, MIN_Y, MAX_Y);
            const complex = new Complex(normX, normY);
            const steps = complex.stepsToInfinity();
            const offset = ((y * RESOLUTION) + x) * 4;

            // const gs = getGreyscale(steps); // brightness of given pixel
            const [r,g,b] = getColor(steps); // tuple of RGB values between 0 and 255

            // r
            pixels[offset] = r;

            // g
            pixels[offset + 1] = g;

            // b
            pixels[offset + 2] = b;

            // a (dont need if `{alpha: false}`)
            // pixels[offset + 3] = 255;
          };
        };

        ctx.putImageData(imageData, 0, 0)
      }

      const getHoveredValue = (event) => {
        const bounding = canvas.getBoundingClientRect();
        const x = event.clientX - bounding.left;
        const y = event.clientY - bounding.top;
        const complex = new Complex(scale(x, MIN_X, MAX_X), scale(y, MIN_Y, MAX_Y));

        return complex.toString();
      };

      const setHoveredValue = (v) => {
        document.getElementById("hovered-value").textContent = `hovered at: ${v}`;
      }

      const clearHoveredValue = () => {
        document.getElementById("hovered-value").textContent = "";
      }

      canvas.addEventListener("mousemove", (e) => {
        setHoveredValue(getHoveredValue(e));
      });

      canvas.addEventListener("mouseover", (e) => {
        setHoveredValue(getHoveredValue(e));
      });

      canvas.addEventListener("mouseout", clearHoveredValue);

      const getClickedValue = (event) => {
        const bounding = canvas.getBoundingClientRect();
        const x = event.clientX - bounding.left;
        const y = event.clientY - bounding.top;
        const complex = new Complex(scale(x, MIN_X, MAX_X), scale(y, MIN_Y, MAX_Y));

        recenterAndZoom(complex);
        document.getElementById("centered-value").textContent = complex.toString();
        document.getElementById("scale-value").textContent = `2^${Math.log2(1/SCALE)}`;
        const h = document.getElementById("helper");
        if (h) {
          h.remove();
        }
        doWork();
      };
      canvas.addEventListener("click", getClickedValue);

      document.getElementById("reset-button").addEventListener("click", () => {
        initValues();
        doWork();
      });

      document.body.onload = doWork;
    </script>
  </body>
</html>
